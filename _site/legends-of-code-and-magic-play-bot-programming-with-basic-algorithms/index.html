<!DOCTYPE html><html lang="en"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" /><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="keywords" content="Full-Stack Developer, Programming, Machine Learning, IoT"><meta name="theme-color" content="#000000"><title>Legends of Code and Magic เล่น Bot Programming ด้วย Basic Algorithms | Jirawat Boonkumnerd</title><meta name="generator" content="Jekyll v4.0.0" /><meta property="og:title" content="Legends of Code and Magic เล่น Bot Programming ด้วย Basic Algorithms" /><meta name="author" content="ntsd" /><meta property="og:locale" content="en_US" /><meta name="description" content="Codingame เป็นเว็บที่มีเว็บโปรแกรมมิ่งแนว Bot Programming ที่ให้ผู้เล่นเขียนโค๊ดเพื่อให้บอทไปสู้กับบอทคนอื่น" /><meta property="og:description" content="Codingame เป็นเว็บที่มีเว็บโปรแกรมมิ่งแนว Bot Programming ที่ให้ผู้เล่นเขียนโค๊ดเพื่อให้บอทไปสู้กับบอทคนอื่น" /><link rel="canonical" href="https://ntsd.me/legends-of-code-and-magic-play-bot-programming-with-basic-algorithms/" /><meta property="og:url" content="https://ntsd.me/legends-of-code-and-magic-play-bot-programming-with-basic-algorithms/" /><meta property="og:site_name" content="Jirawat Boonkumnerd" /><meta property="og:image" content="https://ntsd.me/pwa/icons/512.png" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2018-08-05T19:30:54+07:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:image" content="https://ntsd.me/pwa/icons/512.png" /><meta property="twitter:title" content="Legends of Code and Magic เล่น Bot Programming ด้วย Basic Algorithms" /><meta name="twitter:site" content="@ntsd_me" /><meta name="twitter:creator" content="@ntsd" /><meta property="fb:admins" content="jo.ntsd" /><meta property="article:publisher" content="ntsd.me" /><meta property="fb:app_id" content="523337598616322" /> <script type="application/ld+json"> {"dateModified":"2018-08-05T19:30:54+07:00","image":"https://ntsd.me/pwa/icons/512.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://ntsd.me/legends-of-code-and-magic-play-bot-programming-with-basic-algorithms/"},"url":"https://ntsd.me/legends-of-code-and-magic-play-bot-programming-with-basic-algorithms/","author":{"@type":"Person","name":"ntsd"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://ntsd.me/pwa/icons/512.png"},"name":"ntsd"},"description":"Codingame เป็นเว็บที่มีเว็บโปรแกรมมิ่งแนว Bot Programming ที่ให้ผู้เล่นเขียนโค๊ดเพื่อให้บอทไปสู้กับบอทคนอื่น","headline":"Legends of Code and Magic เล่น Bot Programming ด้วย Basic Algorithms","@type":"BlogPosting","datePublished":"2018-08-05T19:30:54+07:00","@context":"https://schema.org"}</script><link rel="preconnect" href="https://cdnjs.cloudflare.com"><link rel="manifest" href="/pwa/manifest.json" defer><link rel="stylesheet" href="/css/bootstrap.min.css" defer><link rel="stylesheet" href="/css/ntsd-blog.min.css" defer><link rel="shortcut icon" href="/favicon.ico" defer><link rel="apple-touch-icon" href="/favicon.ico" defer> <script></script><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class="container-fluid"><div class="navbar-header page-scroll"> <button type="button" class="navbar-toggle"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button> <a class="navbar-brand" href="/">Jirawat Boonkumnerd</a></div><div id="huxblog_navbar"><div class="navbar-collapse"><ul class="nav navbar-nav navbar-right"><li> <a href="/">Home</a><li> <a href="/categories/">Categories</a><li> <a href="/portfolio/">Portfolio</a><li> <a href="/tags/">Tags</a></ul></div></div></div></nav><script> var $body = document.body; var $toggle = document.querySelector('.navbar-toggle'); var $navbar = document.querySelector('#huxblog_navbar'); var $collapse = document.querySelector('.navbar-collapse'); var __HuxNav__ = { close: function(){ $navbar.className = " "; setTimeout(function() { if($navbar.className.indexOf('in') < 0) { $collapse.style.height = "0px"; } }, 400); }, open: function() { $collapse.style.height = "auto"; $navbar.className += " in"; } }; $toggle.addEventListener('click', function(e) { if ($navbar.className.indexOf('in') > 0) { __HuxNav__.close(); } else{ __HuxNav__.open(); } }); document.addEventListener('click', function(e){ if(e.target == $toggle) return; if(e.target.className == 'icon-bar') return; __HuxNav__.close(); }); </script><style type="text/css"> header.intro-header { position: relative; background-image: url('/../img/in-post/2018-8-5-legends-of-code-and-magic-play-bot-programming-with-basic-algorithms/post-legends-of-code-and-magic.png'); }</style><header class="intro-header" ><div class="intro-header-inner"><div class="header-mask"></div><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class="post-heading"> <span class="categories"> <a class="category" href="/categories/#Programming" title="Programming">Programming</a> </span> <span class="tags"> <a class="tag" href="/tags/#Artificial Intelligence" title="Artificial Intelligence">Artificial Intelligence</a> <a class="tag" href="/tags/#Programming" title="Programming">Programming</a> <a class="tag" href="/tags/#Python" title="Python">Python</a> </span><h1>Legends of Code and Magic เล่น Bot Programming ด้วย Basic Algorithms</h1><h2 class="subheading">สร้างบอทเกมเพื่อเล่นเกมไพ่แข่งกับคนอื่น</h2><span class="meta">Posted by ntsd on August 5, 2018</span></div></div></div></div></div></header><article><div class="container"><div class="row"><div class=" col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 post-container"><p>Codingame เป็นเว็บที่มีเว็บโปรแกรมมิ่งแนว Bot Programming ที่ให้ผู้เล่นเขียนโค๊ดเพื่อให้บอทไปสู้กับบอทคนอื่น</p><p>สามารถเล่นได้ที่นี่ <a href="https://www.codingame.com/contests/legends-of-code-and-magic-marathon">Link</a></p><p>สำหรับคนที่ยังไม่ค่อยเข้าใจระบบเกม ให้ลองเลื่อนลงไปดู Game loops and Input ก่อน</p><h2 id="requirement-skills">Requirement skills</h2><ul><li>Programming (Python Syntax)<li>Basic Algorithms<li>OOP นิดหน่อย</ul><p>LEGENDS OF CODE AND MAGIC เป็นเกมนี้จะเป็นบอร์ดเกมคล้าย Hearthstone</p><p>ตัวอย่างเกม <a href="https://www.codingame.com/replay/328489470">https://www.codingame.com/replay/328489470</a></p><p>มีผู้เล่นสองคนใช้ไพ่ต่อสู้กันใครเลือดหมดก่อนแพ้</p><p>โดยจะแบ่งเป็น 2 phases</p><p>phase แรกจะเป็นการเลือกไพ่ 1 ใน 3 จากไพ่ที่สุ่มมา จนครบ 30 ใบ</p><p>phase ที่สองจะเป็นการ Battle</p><p>โดยใน battle phase จะมีมานาเริ่มต้น 1 และเพิ่ม 1 ทุกๆเทริน</p><p>โดยมานาสามารถนำไปจ่ายเพื่อใช้ไพ่</p><p>ในเกมจะมีไพ่ 2 ชนิด คือไพ่ creatures กับ items แต่ผมจะอธิบายแค่ creature</p><p>เมื่อใช้ไพ่ creature จากบนมือจะลงไปบนบอร์ด โดย creature สามารถโจมตีได้เมื่ออยู่บนบอร์ด</p><p>เลือดจะลดหากโจมตี creature ด้วยกันเอง</p><h2 id="creature-abilities">creature abilities</h2><p>creature จะมีความสามามารถพิเศษแตกต่างกันดังนี้</p><pre><code class="language-Text">Breakthrough: Creatures with Breakthrough can deal extra damage to the opponent when they attack enemy creatures. If their attack damage is greater than the defending creature's defense, the excess damage is dealt to the opponent.
Charge: Creatures with Charge can attack the turn they are summoned.
Drain: Creatures with Drain heal the player of the amount of the damage they deal (when attacking only).
Guard: Enemy creatures must attack creatures with Guard first.
Lethal: Creatures with Lethal kill the creatures they deal damage to.
Ward: Creatures with Ward ignore once the next damage they would receive from any source. The "shield" given by the Ward ability is then lost.
</code></pre><h2 id="class">Class</h2><h3 id="import-อะไรให้พร้อม">import อะไรให้พร้อม</h3><pre><code class="language-Python">import sys # ใช้เพื่อ print log
from copy import deepcopy  # deepcopy เพื่อให้ object ต่างๆ ไม่ reference เวลา simulate
</code></pre><h3 id="class-player">class Player</h3><pre><code class="language-Python">class Player:
    def __init__(self):
        self.mana_curve = [0, 7, 6, 5, 4, 3, 0, 0, 0, 0, 0, 0, 0] # mana curve ใช่เพื่อเลือไพ่ให้ได้ curve ตามต้องการ
    def setEnemy(self, player):
        self.op = player
    def update(self, player_health, player_mana, player_deck, player_rune): # ใช้เพื่ออัพเดตค่าทุกๆเทริน
        self.__dict__.update(l for l in locals().items() if l[0] != 'self') # map local vars ใส่ self vars
        self.hands = []
        self.boards = []
    def addHand(self, card): # ใช้เพื่อเพิ่มไพ่ในมือ
        self.hands.append(card)
    def addBoard(self, card):  # ใช้เพื่อเพิ่มไพ่บอร์ด
        self.boards.append(card)
</code></pre><h3 id="class-card">class Card</h3><pre><code class="language-Python">class Card:
    def __init__(self, card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw):
        self.__dict__.update(l for l in locals().items() if l[0] != 'self')
        self.action = 1
        self.shield = 1 if 'W' in abilities else 0
        self.lethal = 1 if 'L' in abilities else 0
        self.guard = 1 if 'G' in abilities else 0
        self.charge = 1 if 'C' in abilities else 0
        self.drain = 1 if 'D' in abilities else 0
        self.breakthrough = 1 if 'B'in abilities else 0
        self.live = 1
    def __hash__(self): # ใช้เพื่อ hash เปรียบเทียบ object ด้วย id
         return hash(self.instance_id)
    def __eq__(self, other): # ใช้เพื่อเปรียบเทียบ Equal ของ Object
        return (
            self.__class__ == other.__class__ and
            self.instance_id == other.instance_id
        )
</code></pre><h3 id="class-creature">class Creature</h3><pre><code class="language-Python">class Creature(Card): # inheritance Card เพื่อบอกว่าเป็น Subclass ของ Card
    def attackTarget(self, target): # ใช้เมื่อโจมตี Creature ตัวอื่น
        self.action = 0
        if self.shield: # เมื่อดาเมจโดน shield จะหาย
            self.shield = 0
        else:
            self.defense -= target.attack # เลือดลดด้วยพลังโจมตีของเป้าหมาย
            if self.defense &lt;=0 or (target.lethal and type(target) is Creature):
                self.live = 0 # เมื่อเลือดหมด
        if target.shield: # damage to target
            target.shield = 0
        else:
            target.defense -= self.attack # เลือดเป้าหมายลดด้วยพลังโจมตีของผู้ตี
            if target.defense &lt;=0 or (self.lethal and type(target) is Creature):
                target.live = 0
</code></pre><h3 id="class-item">class Item</h3><pre><code class="language-Python">class Item(Card):
    def use(self, target):
        pass
</code></pre><h2 id="algorithms">Algorithms</h2><p>โดยวิธีที่ผมใช้เป็น Basic Algorithms ในการสร้าง Rules ต่างๆ ในการเล่นเกม เพื่อทำให้ชนะการเล่น โดยผมจะใส่เป็น Method ของ Player ดังนี้</p><h3 id="draft-card">Draft Card</h3><p>โดยผมจะเลือกตาม mana curve เป็นหลักและ value ของไพ่ โดยผมใช้ attack * defence เป็น vaule ของไพ่</p><pre><code class="language-Python">def draft(self, draft_list): # เลือกไพ่ 1 ใน 3
        max_value = 0
        card_no=0
        for i, card in enumerate(draft_list):
            if type(card) is Creature: # ดูว่าไพ่เป็นชนิด Creature
                value = card.attack * card.defense
                if self.mana_curve[card.cost] &gt; 0:
                    value += 100 # ถ้า curve ยังไม่เต็มให้เลือกตาม curve ก่อน โดยเพิ่ม value
                if value &gt; max_value: # เลือกไพ่ที่มี value มากสุด
                    max_value = value
                    card_no = i
        self.mana_curve[draft_list[card_no].cost]-=1
        print('PICK {}'.format(card_no))
</code></pre><h3 id="battle-parse">Battle Parse</h3><p>โดยผมจะ summon creatures ก่อน แล้วจึงโจมตีฝั่งตรงข้าม</p><p>โดยจะทำเป็น action list ดังนี้</p><pre><code class="language-Python">    def useItem(self): # ผมยังไม่ได้ทำให้ใช้ item ได้เลยว่างไว้ก่อน
        return []

    def play(self):
        action_list = []
        action_list += self.summon()
        action_list += self.useItem()
        action_list += self.creatureAttack()
        print(';'.join(action_list)) #  actions จะแบ่งด้วย ;
</code></pre><h3 id="summon">Summon</h3><p>ต่อมาเป็นการเรียก Creature จากบนมือ โดยผมจะเลือกตัวที่มานามากที่สุดก่อน</p><pre><code class="language-Python">def summon(self):
        mana=self.player_mana
        action_list = []
        boards_count = len(self.boards)
        creature_on_hand = filter(lambda x: type(x) is Creature ,self.hands) # filter เฉพาะ Creature ที่อยู่บนมือ
        for c in sorted(creature_on_hand, key=lambda x: x.cost, reverse=True): # เรียงตาม มานา
            if boards_count &lt; 6: # เช็คถ้าบอร์ดยังไม่เต็ม
                if c.cost&lt;=mana: # เช็คว่ายังเหลือมานายังพอเรียก
                    mana-=c.cost
                    action_list.append("SUMMON {}".format(c.instance_id))
                    if c.charge: # ถ้ามี charge ability จะสามารถตีได้เลย ผมเลยใส่ในบอร์ด
                        self.boards.append(c)
                    boards_count += 1
        return action_list # return action list
</code></pre><h3 id="attack">Attack</h3><p>ในการโจมตีของ creature ผมจะสร้าง rules ลำดับความสำคัญให้มันว่าจะต้องทำอะไรก่อน โดยผมจะสร้าง Rule Class โดยจะใส่ lambda functions ให้กับมันดังนี้</p><ul><li>mySort - เรียง creatures ของเรา<li>myFilter - filter creatures ของเรา<li>opSort - เรียง creatures ของคู่ต่อสู้<li>opFilter - filter creatures ของคู่ต่อสู้<li>rule - กฏเพื่อให้เข้าเงื่อนไข</ul><h3 id="rule-class">Rule Class</h3><pre><code class="language-Python">class AttackRule:
    def __init__(self, mySort, myFilter, opSort, opFilter, rule):
        self.__dict__.update(l for l in locals().items() if l[0] != 'self')
</code></pre><h3 id="creature-attack">Creature Attack</h3><p>ผมจะ simulate เพื่อให้ creature โจมตี crature ฝั่งตรงข้ามก่อนตามเงื่อนไขที่กำหนด จากนั้นถ้าเข้าเงื่อนไขจึงเก็บ action และบันทึกค่าว่าโจมตีจริงๆ</p><pre><code class="language-Python">def creatureAttack(self):
        action_list = []

        attack_rules=[
            # โจมตี taunt creature ให้ได้คุ้มค่า
            AttackRule(lambda my: -my.defense, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op: my.live and op.live==0),
            # โจมตี taunt creature โดยที่ของเรายังไม่ตาย
            AttackRule(lambda my: -my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op:  my.live),
            # โจมตี taunt creature ไม่ว่ายังไงก็ตาม
            AttackRule(lambda my: -my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op: True),
            # โจมตีโดยที่ creature ฝั่งตรงข้ามตาย แต่ฝั่งเราไม่ตาย
            AttackRule(lambda my: my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: True,
            lambda my, op: my.live and op.live==0),
            # โจมตีโดยที่ creature ฝั่งตรงข้ามตาย
            AttackRule(lambda my: my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: True,
            lambda my, op: op.live==0), # and self.player_health &lt; self.op.player_health
        ]

        for attack_rule in attack_rules:# loop ทุกๆ rules
            # sort และ filter creatures ตาม rule ที่กำหนด
            for my_c in sorted(filter(attack_rule.myFilter, self.boards), key=attack_rule.mySort):
                for op_c in sorted(filter(attack_rule.opFilter, self.op.boards), key=attack_rule.opSort):
                    my_c_temp = deepcopy(my_c) # deep copy เพื่อ simulate ว่าถ้าตีผลจะเป็นยังไง
                    op_c_temp = deepcopy(op_c)
                    my_c_temp.attackTarget(op_c_temp)
                    if attack_rule.rule(my_c_temp, op_c_temp): # ถ้าลองโจมตีแล้วเข้าเงื่อนไขให้ทำการบันทึก action
                        my_c = my_c_temp
                        op_c = op_c_temp
                        action_list.append("ATTACK {} {} Pika!".format(my_c.instance_id, op_c.instance_id))
                        my_c.action = 0 # เมื่อโจมตีแล้วจะตีไม่ได้อีก
                        if not my_c.live:
                            self.boards.remove(my_c) # ถ้าตายจำออกจากบอร์ด
                        if not op_c.live:
                            self.op.boards.remove(op_c)
                        break

        # สั่งให้ตีฮีโร่ฝั่งตรงข้ามเมื่อไม่เข้าเงื่อนไขข้างบน
        for my_c in self.boards:
            if my_c.action:
                action_list.append("ATTACK {} {} Pikachu!!".format(my_c.instance_id, -1))
                my_c.action = 0

        return action_list
</code></pre><h3 id="game-loops-and-input">Game loops and Input</h3><p>main ของ Bot ใช้เพื่ออัพเดตค่าต่างๆของเกมโดยผู้เล่นจะสลับฝั่งกันเล่นและอัพเดตค่าผ่านทาง input, output</p><p>โดย Bot Game ใน Codingame นั้นจะประมวลผลเกมเป็น loop ดังนี้</p><p>game ประมวลผล</p><p>player 1 รับค่า และ ประมวลผล</p><p>player 1 ส่งค่า</p><p>game ประมวลผล</p><p>player 2 รับค่า และ ประมวลผล</p><p>player 2 ส่งค่า</p><p>เป็น loop จนกว่าจะจบเกม</p><h3 id="main">Main</h3><pre><code class="language-Python">my_player = Player()
op_player = Player()
my_player.setEnemy(op_player)
while True:
    player_health, player_mana, player_deck, player_rune = [int(j) for j in input().split()]
    my_player.update(player_health, player_mana, player_deck, player_rune) # อัพเดตค่าของ player ทุกๆเทริน
    player_health, player_mana, player_deck, player_rune = [int(j) for j in input().split()]
    op_player.update(player_health, player_mana, player_deck, player_rune)

    opponent_hand = int(input())
    card_count = int(input())
    draft_list = []
    for i in range(card_count):
        # Input card และ map แปลง input ที่เป็นตัวเลขให้เป็น Int
        card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw = map(lambda x: int(x) if x[-1].isdigit() else x,input().split())
        if card_type!=0: # เช็คว่าเป็นไพ่ชนิดใด
            card = Item(card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw)
        else:
            card = Creature(card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw)
        if my_player.player_mana==0:
            draft_list.append(card)
        elif location==0: # เช็คว่ายู่บนมือของเรา
            my_player.addHand(card)
        elif location==1: # เช็คว่ายู่บนสนามของเรา
            my_player.addBoard(card)
        elif location==-1: # เช็คว่ายู่บนสนามของคู่แข่ง
            op_player.addBoard(card)

    if my_player.player_mana==0: # ถ้ามานาเท่ากับ 0 แสดงว่าเป็น draft parse
        my_player.draft(draft_list)
    else:
        my_player.play()
</code></pre><h2 id="full-code">Full Code</h2><pre><code class="language-Python">import sys
from copy import deepcopy

def log(*args,**kwargs):
    print(*args,**kwargs, file=sys.stderr)

class AttackRule:
    def __init__(self, mySort, myFilter, opSort, opFilter, rule):
        self.__dict__.update(l for l in locals().items() if l[0] != 'self')

class Player:
    def __init__(self):
        self.mana_curve = [0, 7, 6, 5, 4, 3, 0, 0, 0, 0, 0, 0, 0]
    def setEnemy(self, player):
        self.op = player
    def update(self, player_health, player_mana, player_deck, player_rune):
        self.__dict__.update(l for l in locals().items() if l[0] != 'self')
        self.hands = []
        self.boards = []
    def addHand(self, card):
        self.hands.append(card)
    def addBoard(self, card):
        self.boards.append(card)

    def draft(self, draft_list):
        max_value = 0
        card_no=0
        for i, card in enumerate(draft_list):
            if type(card) is Creature: #todo add item pick
                value = card.attack * card.defense
                if self.mana_curve[card.cost] &gt; 0:
                    value += 100
                if value &gt; max_value:
                    max_value = value
                    card_no = i
        self.mana_curve[draft_list[card_no].cost]-=1
        print('PICK {}'.format(card_no))

    def summon(self): # to do make mana zero
        mana=self.player_mana
        action_list = []
        boards_count = len(self.boards)
        creature_on_hand = filter(lambda x: type(x) is Creature ,self.hands)
        for c in sorted(creature_on_hand, key=lambda x: x.cost, reverse=True):
            if boards_count &lt; 6 or 1: # to do need to check summon again after trade
                if c.cost&lt;=mana:
                    mana-=c.cost
                    action_list.append("SUMMON {}".format(c.instance_id))
                    if c.charge:
                        self.boards.append(c)
                    boards_count += 1
        return action_list

    def creatureAttack(self):
        action_list = []

        attack_rules=[
            # trade taunt value
            AttackRule(lambda my: -my.defense, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op: my.live and op.live==0),
            # attack taunt and survive
            AttackRule(lambda my: -my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op:  my.live),
            # attack taunt
            AttackRule(lambda my: -my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.guard==1,
            lambda my, op: True),
            # trade lethal
            AttackRule(lambda my: my.defense, lambda my: my.action,
            lambda op: -op.attack, lambda op: op.lethal==1,
            lambda my, op: op.live==0),
            # trade value
            AttackRule(lambda my: my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: True,
            lambda my, op: my.live and op.live==0),
            # trade equal
            AttackRule(lambda my: my.attack, lambda my: my.action,
            lambda op: -op.attack, lambda op: True,
            lambda my, op: op.live==0), # and self.player_health &lt; self.op.player_health
        ]

        for attack_rule in attack_rules:
            for my_c in sorted(filter(attack_rule.myFilter, self.boards), key=attack_rule.mySort):
                for op_c in sorted(filter(attack_rule.opFilter, self.op.boards), key=attack_rule.opSort):
                    my_c_temp = deepcopy(my_c)
                    op_c_temp = deepcopy(op_c)
                    my_c_temp.attackTarget(op_c_temp)
                    if attack_rule.rule(my_c_temp, op_c_temp):
                        my_c = my_c_temp
                        op_c = op_c_temp
                        action_list.append("ATTACK {} {} Pika!".format(my_c.instance_id, op_c.instance_id))
                        my_c.action = 0
                        if not my_c.live:
                            self.boards.remove(my_c)
                        if not op_c.live:
                            self.op.boards.remove(op_c)
                        break
        # go face
        for my_c in self.boards:
            if my_c.action:
                action_list.append("ATTACK {} {} Pikachu!!".format(my_c.instance_id, -1))
                my_c.action = 0

        return action_list

    def useItem(self):# item red target op minion
        return []

    def play(self):
        action_list = []
        action_list += self.summon()
        action_list += self.useItem()
        action_list += self.creatureAttack()
        print(';'.join(action_list))

class Card:
    def __init__(self, card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw):
        self.__dict__.update(l for l in locals().items() if l[0] != 'self')
        self.action = 1
        self.shield = 1 if 'W' in abilities else 0
        self.lethal = 1 if 'L' in abilities else 0
        self.guard = 1 if 'G' in abilities else 0
        self.charge = 1 if 'C' in abilities else 0
        self.drain = 1 if 'D' in abilities else 0
        self.breakthrough = 1 if 'B'in abilities else 0
        self.live = 1
    def __hash__(self):
         return hash(self.instance_id)
    def __eq__(self, other):
        return (
            self.__class__ == other.__class__ and
            self.instance_id == other.instance_id
        )

class Item(Card):
    def use(self, target):
        pass

class Creature(Card):
    def attackTarget(self, target): # attack op creature
        self.action = 0
        if self.shield: # damage to self
            self.shield = 0
        else:
            self.defense -= target.attack
            if self.defense &lt;=0 or (target.lethal and type(target) is Creature):
                self.live = 0
        if target.shield: # damage to target
            target.shield = 0
        else:
            target.defense -= self.attack
            if target.defense &lt;=0 or (self.lethal and type(target) is Creature):
                target.live = 0

my_player = Player()
op_player = Player()
my_player.setEnemy(op_player)
# op_player.setEnemy(my_player)
while True:
    player_health, player_mana, player_deck, player_rune = [int(j) for j in input().split()]
    my_player.update(player_health, player_mana, player_deck, player_rune)
    player_health, player_mana, player_deck, player_rune = [int(j) for j in input().split()]
    op_player.update(player_health, player_mana, player_deck, player_rune)

    opponent_hand = int(input())
    card_count = int(input())
    draft_list = []
    for i in range(card_count):
        card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw = map(lambda x: int(x) if x[-1].isdigit() else x,input().split())
        if card_type!=0:
            card = Item(card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw)
        else:
            card = Creature(card_number, instance_id, location, card_type, cost, attack, defense, abilities, my_health_change, opponent_health_change, card_draw)
        if my_player.player_mana==0:
            draft_list.append(card)
        elif location==0:
            my_player.addHand(card)
        elif location==1:
            my_player.addBoard(card)
        elif location==-1:
            op_player.addBoard(card)

    if my_player.player_mana==0:
        my_player.draft(draft_list)
    else:
        my_player.play()
</code></pre><p>การเขียนอาจะจะเข้าใจยากไปหน่อย สามารถติชมกันได้ครับ</p><hr style="visibility: hidden;"><ul class="pager"><li class="previous"> <a href="/welcome-to-my-blog/" data-toggle="tooltip" data-placement="top" title="Welcome to my blog"> Previous<br> <span>Welcome to my blog</span> </a><li class="next"> <a href="/python-codegolf/" data-toggle="tooltip" data-placement="top" title="Python Code Golf Cheat Sheet"> Next<br> <span>Python Code Golf Cheat Sheet</span> </a></ul></div><div class=" col-lg-2 col-lg-offset-0 visible-lg-block sidebar-container catalog-container"><div class="side-catalog"><h5> <a class="catalog-toggle" href="#">Contents</a></h5><ul class="catalog-body"></ul></div></div><div class=" col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1 sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href="/tags/">FEATURED TAGS</a></h5><div class="tags"> <a href="/tags/#General" title="General" rel="1"> General </a> <a href="/tags/#Artificial Intelligence" title="Artificial Intelligence" rel="1"> Artificial Intelligence </a> <a href="/tags/#Programming" title="Programming" rel="6"> Programming </a> <a href="/tags/#Python" title="Python" rel="2"> Python </a> <a href="/tags/#Code golf" title="Code golf" rel="1"> Code golf </a> <a href="/tags/#C++" title="C++" rel="1"> C++ </a> <a href="/tags/#aria2" title="aria2" rel="1"> aria2 </a> <a href="/tags/#Network" title="Network" rel="2"> Network </a> <a href="/tags/#OpenWRT" title="OpenWRT" rel="1"> OpenWRT </a> <a href="/tags/#Router" title="Router" rel="1"> Router </a> <a href="/tags/#Embedded" title="Embedded" rel="1"> Embedded </a> <a href="/tags/#Gatsby" title="Gatsby" rel="1"> Gatsby </a> <a href="/tags/#React" title="React" rel="1"> React </a> <a href="/tags/#GraphQL" title="GraphQL" rel="1"> GraphQL </a> <a href="/tags/#Progressive Web App" title="Progressive Web App" rel="1"> Progressive Web App </a> <a href="/tags/#TypeScript" title="TypeScript" rel="2"> TypeScript </a> <a href="/tags/#Facebook Developer" title="Facebook Developer" rel="1"> Facebook Developer </a> <a href="/tags/#ESLint" title="ESLint" rel="1"> ESLint </a></div></section></div></div></div></article><script> function async(u, c) { var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.src = u; if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); } s.parentNode.insertBefore(o, s); } </script> <script> async("https://cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){ anchors.options = { visible: 'always', placement: 'right', icon: '#' }; anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5'); }) </script><style> /* place left on bigger screen */ @media all and (min-width: 800px) { .anchorjs-link{ position: absolute; left: -0.75em; font-size: 1.1em; margin-top : -0.1em; } }</style><footer><div class="container"><div class="row"><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"><li> <a target="_blank" href="https://www.facebook.com/jo.ntsd" aria-label="Facebook" rel="noopener noreferrer"> <svg class="svg-icon logo-facebook"></svg> </a><li> <a target="_blank" href="https://github.com/ntsd" aria-label="Github" rel="noopener noreferrer"> <svg class="svg-icon logo-github"></svg> </a><li> <a target="_blank" href="https://www.linkedin.com/in/ntsd" aria-label="Linkedin" rel="noopener noreferrer"> <svg class="svg-icon logo-linkedin"></svg> </a></ul><div class="copyright"><div> Copyright &copy; Jirawat Boonkumnerd 2020</div><div> Made with ❤️ by <a href="https://ntsd.me">ntsd</a></div></div></div></div></div></footer><script src="/js/snackbar.min.js" defer></script> <script src="/js/sw-registration.min.js" defer></script> <script> function async(u, c) { var d = document, t = 'script', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.src = u; if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); } s.parentNode.insertBefore(o, s); } function asyncStyle(u) { var d = document, t = 'link', o = d.createElement(t), s = d.getElementsByTagName(t)[0]; o.href = u; o.rel="stylesheet"; s.parentNode.insertBefore(o, s); } </script> <script src="/js/jquery.min.js"></script> <script src="/js/ntsd-blog.min.js" defer></script> <script> async("/js/prism.min.js"); asyncStyle("/css/prism.min.css"); </script> <script> async("https://cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function() { var $nav = document.querySelector("nav"); if ($nav) FastClick.attach($nav); }); </script> <script type="text/javascript"> function generateCatalog (selector) { /* interop with multilangual */ if ('' == 'true') { _containerSelector = 'div.post-container.active'; } else { _containerSelector = 'div.post-container'; } /* init */ var P = $(_containerSelector),a,n,t,l,i,c; /* side catalog level */ a = P.find('h1,h2'); /* clean */ $(selector).html(''); /* appending */ a.each(function () { n = $(this).prop('tagName').toLowerCase(); i = "#"+$(this).prop('id'); t = $(this).text(); c = $('<a href="'+i+'" rel="nofollow">'+t+'</a>'); l = $('<li class="'+n+'_nav">').append(c); $(selector).append(l); }); return true; } generateCatalog(".catalog-body"); /* toggle side catalog */ $(".catalog-toggle").click((function(e) { e.preventDefault(); $('.side-catalog').toggleClass("fold"); })); /* Doc: https://github.com/davist11/jQuery-One-Page-Nav Fork by Hux to support padding */ async("/js/jquery.nav.min.js", function () { $('.catalog-body').onePageNav({ currentClass: "active", changeHash: !1, easing: "swing", filter: "", scrollSpeed: 700, scrollOffset: 0, scrollThreshold: .2, begin: null, end: null, scrollChange: null, padding: 80 }); }); </script>
